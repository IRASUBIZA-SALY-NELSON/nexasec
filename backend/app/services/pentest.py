from datetime import datetime
from typing import Optional, List, Dict, Any
from motor.motor_asyncio import AsyncIOMotorDatabase
from bson import ObjectId
from fastapi import HTTPException, status
import asyncio
import aiohttp
import json

from app.models.base import PyObjectId
from app.models.pentest import (
    PentestCreate,
    PentestInDB,
    FindingCreate,
    FindingInDB,
    PentestStatus,
    FindingSeverity,
    FindingStatus,
    PentestType
)
from app.core.config import settings

class PenetrationTester:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.db = db
        self.active_tests: Dict[str, asyncio.Task] = {}

    async def create_pentest(self, user_id: str, pentest_create: PentestCreate) -> PentestInDB:
        """Create a new penetration test."""
        # Check concurrent tests limit
        active_count = await self.db["pentests"].count_documents({
            "user_id": ObjectId(user_id),
            "status": PentestStatus.IN_PROGRESS
        })
        if active_count >= settings.MAX_CONCURRENT_PENTESTS:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Maximum concurrent penetration tests limit reached"
            )

        # Create pentest document
        pentest_dict = pentest_create.model_dump()
        pentest_dict["user_id"] = ObjectId(user_id)
        pentest_dict["status"] = PentestStatus.PENDING
        pentest_dict["created_at"] = datetime.utcnow()
        pentest_dict["updated_at"] = datetime.utcnow()

        # Insert into database
        result = await self.db["pentests"].insert_one(pentest_dict)
        pentest_dict["_id"] = result.inserted_id

        # Create pentest object
        pentest = PentestInDB(**pentest_dict)

        # Start test in background
        self.active_tests[str(pentest.id)] = asyncio.create_task(
            self._run_test(str(pentest.id))
        )

        return pentest

    async def _run_test(self, pentest_id: str) -> None:
        """Execute the penetration test."""
        try:
            # Get pentest from database
            pentest_dict = await self.db["pentests"].find_one({"_id": ObjectId(pentest_id)})
            if not pentest_dict:
                return

            # Update status to in progress
            await self.db["pentests"].update_one(
                {"_id": ObjectId(pentest_id)},
                {
                    "$set": {
                        "status": PentestStatus.IN_PROGRESS,
                        "start_time": datetime.utcnow(),
                        "updated_at": datetime.utcnow()
                    }
                }
            )

            # Run appropriate test based on type
            pentest = PentestInDB(**pentest_dict)
            if pentest.pentest_type == PentestType.WEB:
                await self._run_web_pentest(pentest)
            elif pentest.pentest_type == PentestType.NETWORK:
                await self._run_network_pentest(pentest)
            elif pentest.pentest_type == PentestType.API:
                await self._run_api_pentest(pentest)
            elif pentest.pentest_type == PentestType.MOBILE:
                await self._run_mobile_pentest(pentest)

            # Update status to completed
            await self.db["pentests"].update_one(
                {"_id": ObjectId(pentest_id)},
                {
                    "$set": {
                        "status": PentestStatus.COMPLETED,
                        "end_time": datetime.utcnow(),
                        "progress": 100.0,
                        "updated_at": datetime.utcnow()
                    }
                }
            )

        except Exception as e:
            # Update status to failed
            await self.db["pentests"].update_one(
                {"_id": ObjectId(pentest_id)},
                {
                    "$set": {
                        "status": PentestStatus.FAILED,
                        "end_time": datetime.utcnow(),
                        "error_message": str(e),
                        "updated_at": datetime.utcnow()
                    }
                }
            )
        finally:
            # Remove from active tests
            self.active_tests.pop(pentest_id, None)

    async def _run_web_pentest(self, pentest: PentestInDB) -> None:
        """Execute web application penetration test."""
        try:
            # Test SSL/TLS configuration
            await self._test_ssl_configuration(pentest)
            await self._update_progress(pentest.id, 20.0)

            # Test for XSS vulnerabilities
            await self._test_xss_vulnerabilities(pentest)
            await self._update_progress(pentest.id, 40.0)

            # Test for SQL injection
            await self._test_sql_injection(pentest)
            await self._update_progress(pentest.id, 60.0)

            # Test for CSRF vulnerabilities
            await self._test_csrf_vulnerabilities(pentest)
            await self._update_progress(pentest.id, 80.0)

            # Test security headers
            await self._test_security_headers(pentest)
            await self._update_progress(pentest.id, 100.0)

        except Exception as e:
            raise Exception(f"Web penetration test failed: {str(e)}")

    async def _run_network_pentest(self, pentest: PentestInDB) -> None:
        """Execute network penetration test."""
        # Implement network pentest logic here
        pass

    async def _run_api_pentest(self, pentest: PentestInDB) -> None:
        """Execute API penetration test."""
        # Implement API pentest logic here
        pass

    async def _run_mobile_pentest(self, pentest: PentestInDB) -> None:
        """Execute mobile application penetration test."""
        # Implement mobile pentest logic here
        pass

    async def _create_finding(
        self,
        pentest_id: PyObjectId,
        title: str,
        description: str,
        severity: FindingSeverity,
        impact: Optional[str] = None,
        steps_to_reproduce: Optional[List[str]] = None,
        remediation: Optional[str] = None,
        references: Optional[List[str]] = None,
        cvss_score: Optional[float] = None,
        cwe_id: Optional[str] = None
    ) -> FindingInDB:
        """Create a finding."""
        finding_dict = {
            "pentest_id": pentest_id,
            "title": title,
            "description": description,
            "severity": severity,
            "impact": impact,
            "steps_to_reproduce": steps_to_reproduce,
            "remediation": remediation,
            "references": references,
            "cvss_score": cvss_score,
            "cwe_id": cwe_id,
            "status": FindingStatus.OPEN,
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow()
        }

        # Insert finding
        result = await self.db["findings"].insert_one(finding_dict)
        finding_dict["_id"] = result.inserted_id

        # Update finding counts
        await self.db["pentests"].update_one(
            {"_id": pentest_id},
            {
                "$inc": {f"finding_counts.{severity}": 1},
                "$set": {"updated_at": datetime.utcnow()}
            }
        )

        return FindingInDB(**finding_dict)

    async def _update_progress(self, pentest_id: PyObjectId, progress: float) -> None:
        """Update test progress."""
        await self.db["pentests"].update_one(
            {"_id": pentest_id},
            {
                "$set": {
                    "progress": progress,
                    "updated_at": datetime.utcnow()
                }
            }
        )

    async def get_pentest(self, pentest_id: str) -> Optional[PentestInDB]:
        """Get pentest by ID."""
        if not ObjectId.is_valid(pentest_id):
            return None
        pentest_dict = await self.db["pentests"].find_one({"_id": ObjectId(pentest_id)})
        return PentestInDB(**pentest_dict) if pentest_dict else None

    async def get_pentest_findings(
        self,
        pentest_id: str,
        severity: Optional[FindingSeverity] = None,
        status: Optional[FindingStatus] = None,
        skip: int = 0,
        limit: int = 100
    ) -> List[FindingInDB]:
        """Get findings for a pentest."""
        query = {"pentest_id": ObjectId(pentest_id)}
        if severity:
            query["severity"] = severity
        if status:
            query["status"] = status

        cursor = self.db["findings"].find(query).skip(skip).limit(limit)
        findings = await cursor.to_list(length=limit)
        return [FindingInDB(**f) for f in findings]

    async def update_finding(
        self,
        finding_id: str,
        update_data: dict
    ) -> Optional[FindingInDB]:
        """Update finding details."""
        if not ObjectId.is_valid(finding_id):
            return None

        # Get current finding
        current = await self.db["findings"].find_one({"_id": ObjectId(finding_id)})
        if not current:
            return None

        # Update finding
        update_data["updated_at"] = datetime.utcnow()
        result = await self.db["findings"].find_one_and_update(
            {"_id": ObjectId(finding_id)},
            {"$set": update_data},
            return_document=True
        )

        # Update finding counts if severity changed
        if "severity" in update_data and update_data["severity"] != current["severity"]:
            await self.db["pentests"].update_one(
                {"_id": current["pentest_id"]},
                {
                    "$inc": {
                        f"finding_counts.{current['severity']}": -1,
                        f"finding_counts.{update_data['severity']}": 1
                    },
                    "$set": {"updated_at": datetime.utcnow()}
                }
            )

        return FindingInDB(**result) if result else None

    async def cancel_test(self, pentest_id: str) -> bool:
        """Cancel an active test."""
        if pentest_id in self.active_tests:
            self.active_tests[pentest_id].cancel()
            await self.db["pentests"].update_one(
                {"_id": ObjectId(pentest_id)},
                {
                    "$set": {
                        "status": PentestStatus.CANCELLED,
                        "end_time": datetime.utcnow(),
                        "updated_at": datetime.utcnow()
                    }
                }
            )
            return True
        return False

    async def get_test_progress(self, pentest_id: str) -> Optional[float]:
        """Get test progress."""
        pentest = await self.get_pentest(pentest_id)
        return pentest.progress if pentest else None

    async def cleanup(self) -> None:
        """Cleanup penetration tester resources."""
        for task in self.active_tests.values():
            task.cancel()
        await asyncio.gather(*self.active_tests.values(), return_exceptions=True)
        self.active_tests.clear() 