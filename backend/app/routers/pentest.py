from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from typing import Any, List, Optional, Dict
from app.core.database import get_database
from app.services.auth import get_current_user
from app.services.pentest import PenetrationTester
from app.models.user import UserInDB
from app.models.pentest import (
    PentestType, PentestStatus, PentestScope,
    FindingSeverity, FindingStatus, PentestCreate, PentestResponse, FindingCreate, FindingResponse
)
from pydantic import BaseModel, validator, HttpUrl
from datetime import datetime
import re
import ipaddress
from bson import ObjectId

router = APIRouter()

class PentestCreate(BaseModel):
    name: str
    target: str
    pentest_type: PentestType
    scope: PentestScope
    custom_tests: List[str]
    credentials: Optional[Dict[str, str]] = None
    exclusions: Optional[List[str]] = None

    @validator("name")
    def validate_name(cls, v):
        """Validate pentest name."""
        if not v or not re.match(r"^[a-zA-Z0-9_\- ]{3,50}$", v):
            raise ValueError("Invalid name format")
        return v

    @validator("target")
    def validate_target(cls, v):
        """Validate target URL or IP."""
        try:
            if v.startswith(("http://", "https://")):
                HttpUrl(v)
            else:
                ipaddress.ip_address(v)
        except (ValueError, AttributeError):
            raise ValueError("Invalid target. Must be valid URL or IP address")
        return v

class PentestResponse(BaseModel):
    id: int
    name: str
    target: str
    pentest_type: PentestType
    scope: PentestScope
    status: PentestStatus
    start_date: Optional[datetime]
    end_date: Optional[datetime]
    critical_findings: int
    high_findings: int
    medium_findings: int
    low_findings: int
    info_findings: int
    summary: Optional[dict]

class FindingCreate(BaseModel):
    title: str
    description: str
    severity: FindingSeverity
    vulnerability_type: str
    affected_components: List[str]
    steps_to_reproduce: List[str]
    impact: str
    remediation: str
    references: Optional[List[str]] = None

class FindingResponse(BaseModel):
    id: int
    title: str
    description: str
    severity: FindingSeverity
    status: FindingStatus
    vulnerability_type: str
    affected_components: List[str]
    attack_vector: Optional[str]
    impact: str
    steps_to_reproduce: List[str]
    poc_data: Optional[dict]
    remediation: str
    remediation_complexity: Optional[str]
    remediation_priority: Optional[int]
    is_verified: bool
    cwe_id: Optional[str]
    references: Optional[List[str]]

@router.post("/", response_model=PentestResponse)
async def create_pentest(
    *,
    pentest_in: PentestCreate,
    background_tasks: BackgroundTasks,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Create new penetration test.
    """
    # Check user's pentest limit
    today_start = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
    today_pentests_count = await db["pentests"].count_documents({
        "user_id": ObjectId(current_user.id),
        "created_at": {"$gte": today_start}
    })
    
    if today_pentests_count >= current_user.pentest_limit:
        raise HTTPException(
            status_code=429,
            detail="Daily penetration test limit reached"
        )
    
    # Create pentest record
    pentest_tester = PenetrationTester(db)
    pentest_id = await pentest_tester.create_pentest(
        name=pentest_in.name,
        target=pentest_in.target,
        pentest_type=pentest_in.pentest_type,
        scope=pentest_in.scope,
        custom_tests=pentest_in.custom_tests,
        credentials=pentest_in.credentials,
        exclusions=pentest_in.exclusions,
        user_id=current_user.id
    )
    
    # Get the created pentest
    pentest = await db["pentests"].find_one({"_id": pentest_id})
    
    return {**pentest, "id": str(pentest["_id"])}

@router.get("/{pentest_id}", response_model=PentestResponse)
async def get_pentest(
    pentest_id: str,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Get penetration test by ID.
    """
    pentest = await db["pentests"].find_one({
        "_id": ObjectId(pentest_id),
        "user_id": ObjectId(current_user.id)
    })
    
    if not pentest:
        raise HTTPException(
            status_code=404,
            detail="Penetration test not found"
        )
    
    return {**pentest, "id": str(pentest["_id"])}

@router.get("/{pentest_id}/findings", response_model=List[FindingResponse])
async def get_pentest_findings(
    pentest_id: str,
    severity: Optional[FindingSeverity] = None,
    status: Optional[FindingStatus] = None,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Get findings from penetration test.
    """
    # Check pentest exists and belongs to user
    pentest = await db["pentests"].find_one({
        "_id": ObjectId(pentest_id),
        "user_id": ObjectId(current_user.id)
    })
    
    if not pentest:
        raise HTTPException(
            status_code=404,
            detail="Penetration test not found"
        )
    
    # Query findings
    query = {"pentest_id": ObjectId(pentest_id)}
    
    if severity:
        query["severity"] = severity
    if status:
        query["status"] = status
    
    cursor = db["findings"].find(query)
    findings = await cursor.to_list(length=100)
    
    # Format the response
    return [{**finding, "id": str(finding["_id"])} for finding in findings]

@router.post("/{pentest_id}/findings", response_model=FindingResponse)
async def create_finding(
    pentest_id: str,
    finding_in: FindingCreate,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Add finding to penetration test.
    """
    # Check pentest exists and belongs to user
    pentest = await db["pentests"].find_one({
        "_id": ObjectId(pentest_id),
        "user_id": ObjectId(current_user.id)
    })
    
    if not pentest:
        raise HTTPException(
            status_code=404,
            detail="Penetration test not found"
        )
    
    # Create finding
    pentest_tester = PenetrationTester(db)
    finding_id = await pentest_tester.create_finding(
        pentest_id=ObjectId(pentest_id),
        title=finding_in.title,
        description=finding_in.description,
        severity=finding_in.severity,
        vulnerability_type=finding_in.vulnerability_type,
        affected_components=finding_in.affected_components,
        steps_to_reproduce=finding_in.steps_to_reproduce,
        impact=finding_in.impact,
        remediation=finding_in.remediation,
        references=finding_in.references
    )
    
    # Get created finding
    finding = await db["findings"].find_one({"_id": finding_id})
    
    return {**finding, "id": str(finding["_id"])}

@router.put("/{pentest_id}/findings/{finding_id}", response_model=FindingResponse)
async def update_finding(
    pentest_id: str,
    finding_id: str,
    finding_in: FindingCreate,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Update finding details.
    """
    # Check pentest exists and belongs to user
    pentest = await db["pentests"].find_one({
        "_id": ObjectId(pentest_id),
        "user_id": ObjectId(current_user.id)
    })
    
    if not pentest:
        raise HTTPException(
            status_code=404,
            detail="Penetration test not found"
        )
    
    # Get finding
    finding = await db["findings"].find_one({
        "_id": ObjectId(finding_id),
        "pentest_id": ObjectId(pentest_id)
    })
    
    if not finding:
        raise HTTPException(
            status_code=404,
            detail="Finding not found"
        )
    
    # Update finding using the PenetrationTester service
    pentest_tester = PenetrationTester(db)
    updated_finding_id = await pentest_tester.update_finding(
        finding_id=ObjectId(finding_id),
        pentest_id=ObjectId(pentest_id),
        title=finding_in.title,
        description=finding_in.description,
        severity=finding_in.severity,
        vulnerability_type=finding_in.vulnerability_type,
        affected_components=finding_in.affected_components,
        steps_to_reproduce=finding_in.steps_to_reproduce,
        impact=finding_in.impact,
        remediation=finding_in.remediation,
        references=finding_in.references
    )
    
    # Get updated finding
    updated_finding = await db["findings"].find_one({"_id": updated_finding_id})
    
    return {**updated_finding, "id": str(updated_finding["_id"])}

@router.get("/{pentest_id}/status")
async def get_pentest_status(
    pentest_id: str,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Get penetration test status and progress.
    """
    pentest = await db["pentests"].find_one({
        "_id": ObjectId(pentest_id),
        "user_id": ObjectId(current_user.id)
    })
    
    if not pentest:
        raise HTTPException(
            status_code=404,
            detail="Penetration test not found"
        )
    
    progress = None
    if pentest["status"] == PentestStatus.IN_PROGRESS:
        pentest_tester = PenetrationTester(db)
        progress = await pentest_tester.get_test_progress(pentest_id)
    
    return {
        "status": pentest["status"],
        "progress": progress,
        "findings_summary": {
            "critical": pentest.get("critical_findings", 0),
            "high": pentest.get("high_findings", 0),
            "medium": pentest.get("medium_findings", 0),
            "low": pentest.get("low_findings", 0),
            "info": pentest.get("info_findings", 0)
        }
    }

@router.post("/{pentest_id}/cancel")
async def cancel_pentest(
    pentest_id: str,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Cancel running penetration test.
    """
    pentest = await db["pentests"].find_one({
        "_id": ObjectId(pentest_id),
        "user_id": ObjectId(current_user.id)
    })
    
    if not pentest:
        raise HTTPException(
            status_code=404,
            detail="Penetration test not found"
        )
    
    if pentest["status"] != PentestStatus.IN_PROGRESS:
        raise HTTPException(
            status_code=400,
            detail="Can only cancel tests in progress"
        )
    
    # Cancel test
    pentest_tester = PenetrationTester(db)
    await pentest_tester.cancel_test(pentest_id)
    
    return {"message": "Penetration test cancelled successfully"}

@router.get("/", response_model=List[PentestResponse])
async def list_pentests(
    skip: int = 0,
    limit: int = 10,
    status: Optional[PentestStatus] = None,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    List user's penetration tests.
    """
    query = {"user_id": ObjectId(current_user.id)}
    
    if status:
        query["status"] = status
    
    cursor = db["pentests"].find(query).skip(skip).limit(limit).sort("created_at", -1)
    pentests = await cursor.to_list(length=limit)
    
    # Format the response
    return [{**pentest, "id": str(pentest["_id"])} for pentest in pentests] 