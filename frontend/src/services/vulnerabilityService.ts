import { api } from './api';
import { API_URL } from '@/lib/api';
import { Vulnerability } from "@/types/index";

export const vulnerabilityService = {
  fetchVulnerabilities: async (filters = {}): Promise<Vulnerability[]> => {
    try {
      const qs = new URLSearchParams(filters as Record<string, string>).toString();
      const response = await api.get(`/vulnerabilities${qs ? `?${qs}` : ''}`);
      return response || [];
    } catch (error) {
      console.error('Error fetching vulnerabilities:', error);
      throw new Error('Failed to fetch vulnerabilities');
    }
  },

  getVulnerabilityById: async (id: string): Promise<Vulnerability> => {
    try {
      const response = await api.get(`/vulnerabilities/${id}`);
      return response;
    } catch (error) {
      console.error(`Error fetching vulnerability ${id}:`, error);
      throw new Error('Failed to fetch vulnerability details');
    }
  },

  updateVulnerabilityStatus: async (id: string, status: string): Promise<Vulnerability> => {
    try {
      const response = await api.patch(`/vulnerabilities/${id}`, { status });
      return response;
    } catch (error) {
      console.error(`Error updating vulnerability ${id}:`, error);
      throw new Error('Failed to update vulnerability status');
    }
  }
};

// Export individual functions for backward compatibility
export const fetchVulnerabilities = vulnerabilityService.fetchVulnerabilities;
export const getVulnerabilityById = vulnerabilityService.getVulnerabilityById;
export const updateVulnerabilityStatus = vulnerabilityService.updateVulnerabilityStatus;

export async function runVulnerabilityScan(): Promise<{ success: boolean, message: string }> {
  try {
    const response = await fetch(`${API_URL}/api/vulnerabilities/scan`, {
      method: 'POST',
    });

    if (!response.ok) {
      throw new Error('Failed to initiate vulnerability scan');
    }

    return await response.json();
  } catch (error) {
    console.error('Error initiating vulnerability scan:', error);
    throw error;
  }
}